package perseus.morph;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.jdom.Element;
import org.jdom.output.XMLOutputter;

import perseus.document.Renderer;
import perseus.language.Language;
import perseus.morph.dao.HibernateParseDAO;
import perseus.morph.dao.ParseDAO;
import perseus.util.DisplayPreferences;
import perseus.util.StringUtil;

/**
 * A morphological parse of a particular form. Contains a set of information
 * about a form, a list of the form's features, and the lemma alleged to be
 * the source of the form.
 */
public class Parse implements Comparable<Parse> {
	    
    /**
     * Note that this does not correspond to the index of the morphcode,
     * only to each feature's relative position with respect to the others
     * (e.g., MorphCode.POSSESSIVE and MorphCode.DIALECT both = 
     * morphcode index 9
     */
     
    private static String[] orderedFeatures = new String[] {
	MorphCode.PREFIX,
	MorphCode.POSSESSIVE,
	MorphCode.DEFINITE,
	MorphCode.PART_OF_SPEECH,
	MorphCode.PERSON,
	MorphCode.NUMBER,
	MorphCode.TENSE,
	MorphCode.MOOD,
	MorphCode.VOICE,
	MorphCode.GENDER,
	MorphCode.CASE,
	MorphCode.DEGREE,
	MorphCode.DIALECT,
	MorphCode.OTHER,
	MorphCode.OBJ
    };
    
    private static Map<String,Integer> featureOrder =
	new HashMap<String,Integer>();
    
    static {
	for (int i = 0; i < orderedFeatures.length; i++) {
	    featureOrder.put(orderedFeatures[i], i);
	}
    }
    
    private static Comparator<String> featureOrderComparator =
	new Comparator<String>() {
	
	public int compare(String a, String b) {
	    if (!(featureOrder.containsKey(a))) {
		throw new IllegalArgumentException("Unknown feature " + a);
	    }
	    if (!(featureOrder.containsKey(b))) {
		throw new IllegalArgumentException("Unknown feature " + b);
	    }
	    
	    return featureOrder.get(a).compareTo(featureOrder.get(b));
	}
    };
    
    /** The form represented by this parse */
    private String form;

    /** The form, possibly with some diacritical markings */
    private String expandedForm;

    /** The form, stripped of accents and diacriticals */
    private String bareForm;

    /** The lemma to which this form belongs */
    private Lemma lemma;

    /** The morphological code for this parse's features, as generated by
     * a {@link MorphCodeGenerator}
     */
    private String morphCode;

    private Integer id = null;
    
    /** A hash representing this parse's morphological features */
    private Map<String,String> features =
	new TreeMap<String,String>(featureOrderComparator);
    
    public Parse() {
    }
    
    /**
     * @param lc is the languageCode--now IGNORED; we get it from the lemma
     * @param f the form 
     */
    public Parse (String lc, String f) {
	/*
	languageCode = lc;
	*/
	form = f;
    }

    public Integer getId() {
	return id;
    }

    public void setId(Integer i) {
	id = i;
    }
    
    /**
     * Used by Cruncher2XML
     * @param p Parse to copy
     */
    public Parse(Parse p) {
    	this.form = p.getForm();
    	this.lemma = p.getLemma();
    	this.features.putAll(p.getFeatures());
    }
    
    /**
     * Returns a Map whose keys are possible lemmas that could be the source of
     * `word` and `languageCode`; the value denoted by each key is a list of
     * possible parses with that lemma.
     *
     * @param word the word in question
     * @param languageCode the language of the word
     */
    public static Map<Lemma,List<Parse>> getParses(String word, String languageCode) {
	return getParses(word, languageCode, false, false);
    }

    /**
     * Returns a Map whose keys are possible lemmas that could be the source of
     * `word` and `languageCode`; the value denoted by each key is a list of
     * possible parses with that lemma.
     *
     * @param word the word in question
     * @param languageCode the language of the word
     * @param ignoreAccents true if we should search bare forms
     * @param matchCase true if we should strictly match `word`'s case
     */
    public static Map<Lemma,List<Parse>> getParses(String word,
	String languageCode, boolean ignoreAccents, boolean matchCase) {

	ParseDAO dao = new HibernateParseDAO();
	Map<Lemma,List<Parse>> parses = new TreeMap<Lemma,List<Parse>>();

	List<Parse> parsesFound =
	    dao.getByForm(word, languageCode, ignoreAccents, matchCase);
	for (Parse parse : parsesFound) {
	    Lemma lemma = parse.getLemma();

	    List<Parse> parsesWithLemma;
	    if (parses.containsKey(lemma)) {
		parsesWithLemma = parses.get(lemma);
	    } else {
		parsesWithLemma = new ArrayList<Parse>();
		parses.put(lemma, parsesWithLemma);
	    }
	    parsesWithLemma.add(parse);
	}

	return parses;
    }
    
    /**
     * Returns a list of parses and referenced lemmas in an XML format.
     *
     * Note: this does NOT correspond to the output returned by getParses()
     * or getFlatParses(), which return only the parses (no lemmas). It's
     * provided as a stopgap method to allow us access to the parses and
     * their underlying lemmas/lexicon entries until we can overhaul the
     * Parse class without breaking things that depend on it.
     * 
     * @deprecated not used
     */
    public static String getXMLParses(String word, String languageCode) {
	List<Parse> parses = getFlatParses(word, languageCode);
	StringBuffer output = new StringBuffer();
	
	Set<Lemma> uniqueLemmas = new HashSet<Lemma>();
	
	// We'll output (1) the list of matching parses, and (2) the lemmas
	// referenced by those parses. This is a little clunky, but we want
	// to leave the current parse XML output--which is used by at least
	// one third party--as is.
	output.append("<parseResults>\n");
	output.append("<analysis>\n");
	for (Parse parse : parses) {
	    output.append(parse.toXML());
	    //uniqueLemmas.add(parse.getLemma());
	}
	output.append("</analysis>\n");
	
	output.append("<lemmata>\n");
	for (Lemma lemma : uniqueLemmas) {
	    output.append(lemma.toXML());
	}
	output.append("</lemmata>\n");
	output.append("</parseResults>\n");
	
	return output.toString();
    }
    
    /**
     * Like getParses(), but returns all the parses for a form in a flat list
     * rather than in a hierarchy.
     *
     * @param word the word to parse
     * @param languageCode the languageCode for the language this code is in
     * @return a list of parses for the specified word
     */
    public static List<Parse> getFlatParses(String word, String languageCode) {
	List<Parse> output = new ArrayList<Parse>();
	
	Map<Lemma,List<Parse>> parses = getParses(word, languageCode, true, false);
	for (List<Parse> parseList : parses.values()) {
	    output.addAll(parseList);
	}
	
	return output;
    }
    
    /**
     * Set the features of this Parse object.
     *
     * @param f the morphological code as it appears in the database
     */
    public void setMorphCode(String f) {
	morphCode = f;
	buildFeatures();
    }

    private void buildFeatures() {
	// use putAll() instead of = to avoid clobbering dialect/misc features
	features.putAll(
	    MorphCode.getFeatures(morphCode,
		    Language.forCode(getLemma().getLanguageCode())));
    }

    /**
     * Set the features of this Parse object.
     *
     * @param m the map of morphological features and their values
     */
    public void setFeatures(String morphCode) {
    features = new TreeMap<String, String>(featureOrderComparator);
	setMorphCode(morphCode);
    }

    public void setFeatures(Map<String,String> m) {
	features = m;
    }
    
    /**
     * Set morphological information.
     * 
     * @throws IllegalArgumentException if the key isn't a recognized feature
     * @param key corresponds to a feature in {@link perseus.morph.MorphCode}
     * @param value the value of this feature
     */
    public void setFeature(String key, String value) {
	features.put(key, value);
    }
    
    /**
     * Test if the morphological features associated with
     * this parse has the specified feature
     *
     * @param key the feature in question
     * @return true if this parse has the morph feature of key
     */
    public boolean hasFeature(String key) {
	if (features.isEmpty()) buildFeatures();

	return features.containsKey(key);
    }
    
    /**
     * Get the value for the specified morphological feature for this parse
     *
     * @param key is a key in {@link perseus.morph.MorphCode}
     * @return the value of this feature
     */
    public String getFeature(String key) {
	if (features.isEmpty()) buildFeatures();

	if (! features.containsKey(key)) {
	    return " ";
	}
	return (String) features.get(key);
    }
    
    public Map<String, String> getFeatures() {
    	return features;
    }
    
    /**
     * Retrieve the language code for this parse
     *
     * @return a string that is a constant in {@link perseus.language.LanguageCode}
     */
    public String getCode() { return getMorphCode(); }
    public String getMorphCode() {
	if (features.isEmpty()) buildFeatures();
	
	if (lemma != null && !features.isEmpty()) {
	    morphCode = MorphCode.getCode(
		    features, Language.forCode(getLanguageCode()));
	}

	return morphCode;
    }

    // "Dialect" and "miscellaneous features" may contain more than one value
    // each ("attic epic doric ionic", for example), and are not handled by
    // the MorphCodeGenerator routines, so expose them separately.
    public String getDialects() {
	return features.get(MorphCode.DIALECT);
    }

    public void setDialects(String dialect) {
	features.put(MorphCode.DIALECT, dialect);
    }

    public String getMiscellaneousFeatures() {
	return features.get(MorphCode.OTHER);
    }

    public void setMiscellaneousFeatures(String mf) {
	features.put(MorphCode.OTHER, mf);
    }
    
    /**
     *  Serialize the morphological parse of the given word to a string
     *
     *  @return A String containing parse information for the given Parse object
     */
    public String toString () {
	if (features.isEmpty()) buildFeatures();
	List<String> output = new ArrayList<String>();

	for (int i = 0; i < orderedFeatures.length; i++) {
	    if (features.containsKey(orderedFeatures[i]) && features.get(orderedFeatures[i]) != null) {
		output.add(features.get(orderedFeatures[i]));
	    }
	}
	
	return StringUtil.join(output, " ");
    }

    /**
     *  Serialize the morphological parse of the given word to XML in the 
     *  desired encoding
     *
     *  @param encoding Unicode, UnicodeC, BetaCode, UnicodeD
     *  @return An XML fragment containing parse information for the given
     *  Parse object.
     */
    public Element toXMLElement(DisplayPreferences dp) {
	Renderer renderer = new Renderer(getLemma().getLanguageCode());
	renderer.addLanguageTokenFilters(dp);

	Element root = new Element("analysis")
	    .addContent(
		new Element("form")
		    .setAttribute("lang", getLemma().getLanguageCode())
		    .addContent(renderer.render(form)))
	    .addContent(
		new Element("lemma").addContent(renderer.render(lemma.getDisplayForm())))
	    .addContent(
		new Element("expandedForm").addContent(renderer.render(getExpandedForm())));
	
	for (String featureName : features.keySet()) {
	    root.addContent(
		new Element(featureName).addContent(features.get(featureName)));
	}
	
	return root;
    }

    public String toXML(DisplayPreferences dp) {
	return new XMLOutputter().outputString(toXMLElement(dp));
    }

    /**
     *  Serialize the morphological parse of the given word to XML 
     *
     *  @return An XML fragment containing parse information for the given Parse object
     */
    public String toXML() {
    	DisplayPreferences dp = new DisplayPreferences();
    	dp.put(DisplayPreferences.ARABIC_DISPLAY_KEY, "Buckwalter");
    	dp.put(DisplayPreferences.GREEK_DISPLAY_KEY, "PerseusBetaCode");
	return toXML(dp);
    }
    
    /**
     * Sets the value of the form being parsed.
     *
     * @param s the new form
     */
    public void setForm(String s) {
	form = s;
    }
    
    /**
     * Set the orthographical form for this object instance to s
     * 
     * @param s the value to set expandedForm to
     */
    public void setExpandedForm(String s) {
	expandedForm = s;
    }

    public void setBareForm(String bf) {
	bareForm = bf;
    }
    
    /**
     * Set the lemma for this object instance to s
     *
     * @param s the value to set the lemma attribute to
     */
    public void setLemma(Lemma l) {
	lemma = l;

	if (morphCode != null) buildFeatures();
    }
    
    /**
     * Return the form being parsed, without any length-marks (as distinct from
     * getExpandedForm()).
     *
     * @return the form represented by this Parse
     */
    public String getForm() {
	return form;
    }
    
    /**
     * Return orthographic information about this Parse object
     *
     * @return expandedForm information as a string
     */
    public String getOrth() { return getExpandedForm(); }
    public String getExpandedForm() {
	if (expandedForm == null) return form;
	return expandedForm;
    }
    
    public String getBareForm() {
	return bareForm;
    }

    /**
     * Retrieve the lemma for this object instance.
     *
     * @return the lemma for this object instance
     */
    public Lemma getLemma() {
	return lemma;
    }

    public String getLanguageCode() {
	return lemma == null ? null : getLemma().getLanguageCode();
    }
    
    /**
     * Does the current Parse instance equal the other parse
     *
     * @param o a parse
     * @return true if Parse object o equals this instance of Parse
     */
    public boolean equals (Object o) {
	
	if (!(o instanceof Parse)) {
	    return false;
	}
	
	Parse p = (Parse) o;
	
	return (getLanguageCode().equals(p.getLanguageCode())
		&& getForm().equals(p.getForm())
		&& getLemma().equals(p.getLemma())
		&& getMorphCode().equals(p.getMorphCode()));
    }
    
    /**
     * Compare the current Parse instance to another parse
     *
     * @param o another Parse object
     * @return -1,0,1 if this object is less than, equal to, or greater than the specified object
     */
    public int compareTo(Parse p) throws ClassCastException {
	return getLemma().compareTo(p.getLemma());
    }

    public int hashCode() {
	
	int result = 17;
	
	if (form != null) {
	    result = 37*result + form.hashCode();
	}
	
	if (expandedForm != null) {
	    result = 37*result + expandedForm.hashCode();
	}
	
	if (bareForm != null) {
	    result = 37*result + bareForm.hashCode();
	}
	
	if (morphCode != null) {
	    result = 37*result + morphCode.hashCode();
	}
	
	return result;
    }
}
